{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["const SENTINEL = String.fromCharCode(0);\n\nexport type obj = Record<string, any>;\n\n/**\n * Class for a fast trie map.\n */\nexport class TrieMap<T> {\n  /**\n   * Creates a new instance from existing data.\n   *\n   * @param json - A JSON-string (a previously strinfified TrieMap instance).\n   *\n   * @example\n   * ```js\n   * const json = new TrieMap()\n   *   .set(['some', 'path'], 'value')\n   *   .toJson();\n   *\n   * const trie = Trie.fromJSON(json);\n   * ```\n   */\n  public static fromJSON<T>(json: string): TrieMap<T> {\n    return Object.setPrototypeOf(JSON.parse(json), this.prototype);\n  }\n\n  /**\n   * Creates a new instance from existing data.\n   *\n   * @param iterable - An interable that yields entries.\n   *\n   * @example\n   * ```js\n   * const trie = Trie.fromIterable([\n   *   [['some', 'path'], 'value1'],\n   *   [['other', 'path'], 'value2']\n   * ]);\n   * ```\n   */\n  public static fromIterable<T>(iterable: Iterable<[string[], T]>): TrieMap<T> {\n    const instance: TrieMap<T> = new this();\n    instance.load(iterable);\n    return instance;\n  }\n\n  /**\n   * The TrieMap data structure root.\n   */\n  public root: obj;\n\n  /**\n   * Creates a new TrieMap instance.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   * ```\n   */\n  public constructor() {\n    this.root = {};\n  }\n\n  /**\n   * Returns the number of values in the TrieMap.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   *\n   * trie.\n   *   .set(['some', 'path'], 'value')\n   *   .count;\n   * //=> 1\n   * ```\n   */\n  public get count(): number {\n    let c = 0;\n    this.forEach([], () => {\n      c++;\n    });\n    return c;\n  }\n\n  /**\n   * Ensures a string key of a string[] prefix is valid.\n   *\n   * @throws {Error} if illegal character encountered in prefix.\n   */\n  protected ensureValidKey(key: string): void {\n    // TODO why is key !== '0' necessary?\n    if (key === SENTINEL || key === '0') {\n      throw new Error(\n        'Prefix elements cannot be === to neither ' + SENTINEL + ' || \"0\".',\n      );\n    }\n  }\n\n  /**\n   * Deletes all entries from the TrieMap\n   *\n   * @returns this/self (chainable)\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   * trie.set(['some', 'path'], 'value');\n   * trie.clear();\n   * trie.count;\n   * //=> 0\n   * ```\n   */\n  public clear(): TrieMap<T> {\n    this.root = Object.create(null);\n    return this;\n  }\n\n  /**\n   * Insert multiple entries into the TrieMap.\n   *\n   * @param iterable - An array or other iterable that yields entries.\n   * @returns this/self (chainable)\n   *\n   * @example\n   * ```js\n   * const trie = new Trie().load([\n   *   [['some', 'path'], 'value1'],\n   *   [['other', 'path'], 'value2']\n   * ]);\n   * ```\n   */\n  public load(iterable: Iterable<[string[], T]>): TrieMap<T> {\n    for (const [prefix, value] of iterable) {\n      this.set(prefix, value);\n    }\n    return this;\n  }\n\n  /**\n   * Creates and sets an empty node at the given prefix.\n   *\n   * @param prefix - A string array.\n   */\n  protected setNode(prefix: string[]): obj {\n    let node = this.root;\n    for (let i = 0; i < prefix.length; i++) {\n      this.ensureValidKey(prefix[i]);\n      node = node[prefix[i]] || (node[prefix[i]] = Object.create(null));\n    }\n    return node;\n  }\n\n  /**\n   * Returns the node at the given prefix.\n   *\n   * @param prefix - A string array.\n   */\n  protected getNode(prefix: string[]): obj | undefined {\n    let node: obj = this.root;\n    for (let i = 0; i < prefix.length; i++) {\n      this.ensureValidKey(prefix[i]);\n      node = node[prefix[i]];\n      if (node === undefined) {\n        return;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Assigns a value to the given node.\n   *\n   * @param prefix - A string array.\n   * @param value - The value.\n   */\n  protected nodeSetValue(node: obj, value: T): void {\n    node[SENTINEL] = value;\n  }\n\n  /**\n   * Updates a value at the given node.\n   *\n   * @param prefix - A string array.\n   * @param value - The value.\n   */\n  protected nodeUpdateValue(node: obj, f: (value: T) => T): void {\n    node[SENTINEL] = f(node[SENTINEL]);\n  }\n\n  /**\n   * Gets the value at the given node.\n   *\n   * @param prefix - A string array.\n   */\n  protected nodeGetValue(node: obj): T | undefined {\n    return node[SENTINEL];\n  }\n\n  /**\n   * Deletes the value at the given node.\n   *\n   * @param prefix - A string array.\n   */\n  protected nodeDeleteValue(node: obj): boolean {\n    return Reflect.deleteProperty(node, SENTINEL);\n  }\n\n  /**\n   * Returns whether a node has a value.\n   *\n   * @param prefix - A string array.\n   */\n  protected nodeHasValue(node: obj): boolean {\n    return SENTINEL in node;\n  }\n\n  /**\n   * Insert a value into the TrieMap.\n   *\n   * @param prefix - A string array.\n   * @param value - The value to insert.\n   * @returns this/self (chainable)\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap()\n   *   .set(['some', 'path'], 'value1');\n   *   .set(['other', 'path'], 'value2');\n   * ```\n   */\n  public set(prefix: string[], value: T): TrieMap<T> {\n    this.nodeSetValue(this.setNode(prefix), value);\n    return this;\n  }\n\n  /**\n   * Updates a value in the TrieMap.\n   *\n   * @param prefix - A string array.\n   * @param f - A function that when passed the current value, will return another replacement value.\n   * @returns this/self (chainable)\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   * trie.set(['some', 'path'], 4);\n   *\n   * trie.get(['some', 'path']);\n   * //=> 4\n   *\n   * trie.update(['some', 'path'], (value) => {\n   *   return value + 2\n   * });\n   *\n   * trie.get(['some', 'path']);\n   * //=> 6\n   * ```\n   */\n  public update(prefix: string[], f: (value: T) => T): TrieMap<T> {\n    const node = this.getNode(prefix);\n    if (node) {\n      this.nodeUpdateValue(node, f);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the value at a given prefix or undefined if no node is found.\n   *\n   * @param prefix - A string array.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   * trie.set(['some', 'path'], 4);\n   *\n   * trie.get(['some', 'path']);\n   * //=> 4\n   * ```\n   */\n  public get(prefix: string[]): T | undefined {\n    const node = this.getNode(prefix);\n    if (!node) return;\n    return this.nodeGetValue(node);\n  }\n\n  /**\n   * Returns the value at a given prefix.\n   *\n   * @param prefix - A string array.\n   * @throws {Error} if there is no value at the given prefix.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   *\n   * trie.get(['nonexistent', 'path']);\n   * //=> undefined\n   *\n   * trie.getStrict(['nonexistent', 'path']);\n   * //=> throws Error\n   * ```\n   */\n  public getStrict(prefix: string[]): T {\n    const value = this.get(prefix);\n    if (!value) throw new Error('Value not found.');\n    return value;\n  }\n\n  /**\n   * Returns whether a value exists at the given prefix.\n   *\n   * @param prefix - A string array.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   *\n   * trie.has(['some', 'path']);\n   * //=> false\n   *\n   * trie.set(['some', 'path'], 'value');\n   *\n   * trie.has(['some', 'path']);\n   * //=> true\n   * ```\n   */\n  public has(prefix: string[]): boolean {\n    const node = this.getNode(prefix);\n    return !!node && this.nodeHasValue(node);\n  }\n\n  /**\n   * Deletes the value at the given prefix. Returns whether the operation was successful.\n   *\n   * @param prefix - A string array.\n   * @param prune - Whether or not to delete all values with the given prefix.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   * trie.set(['some', 'path'], 'value');\n   *\n   * trie.has(['some', 'path']);\n   * //=> true\n   *\n   * trie.delete(['some', 'path']);\n   * //=> true (means operation was successful)\n   *\n   * trie.has(['some', 'path']);\n   * //=> false\n   * ```\n   */\n  public delete(prefix: string[]): boolean {\n    let node = this.root;\n    let toPrune = null;\n    let pruneKey = null;\n    let parent;\n    for (let i = 0; i < prefix.length; i++) {\n      parent = node;\n      node = node[prefix[i]];\n      // Prefix does not exist\n      if (node === undefined) {\n        return false;\n      }\n      // Keeping track of a potential branch to prune\n      const numKeys = Object.keys(node).length;\n      if (toPrune !== null) {\n        if (numKeys > 1) {\n          toPrune = null;\n          pruneKey = null;\n        }\n      } else {\n        if (numKeys < 2) {\n          toPrune = parent;\n          pruneKey = prefix[i];\n        }\n      }\n    }\n    if (!this.nodeHasValue(node)) {\n      return false;\n    }\n    if (toPrune && pruneKey) {\n      Reflect.deleteProperty(toPrune, pruneKey);\n    } else {\n      Reflect.deleteProperty(node, SENTINEL);\n    }\n    return true;\n  }\n\n  /**\n   * Deletes the value at the given prefix or all values with the given prefix if ´prune´ is set to true.\n   *\n   * @param prefix - A string array.\n   * @param prune - Whether or not to delete all values with the given prefix.\n   * @throws {Error} if the operation was unsuccessful.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap();\n   *\n   * trie.delete(['nonexistent', 'path']);\n   * //=> false (operation unsuccessful)\n   *\n   * trie.deleteStrict(['nonexistent', 'path']);\n   * //=> throws Error\n   * ```\n   */\n  public deleteStrict(prefix: string[]): void {\n    if (!this.delete(prefix)) {\n      throw new Error('The node at the prefix not found: ' + prefix.join('/'));\n    }\n  }\n\n  /**\n   * Iterate each (value, prefix) with the given prefix.\n   *\n   * @param prefix - A string array.\n   * @param f - A callback function.\n   *\n   * @example\n   * ```js\n   * const directoryFileCounts = new TrieMap()\n   *   .set(['src', 'classes'], 2)\n   *   .set(['src', 'modules'], 6)\n   *   .set(['docs'], 8);\n   *\n   * let totalFiles = 0;\n   * directoryFileCounts.forEach([], (value, prefix) => {\n   *   totalFiles += value;\n   * });\n   * // totalFiles (2 + 6 + 8) is now = 16\n   *\n   * let totalSourceFiles = 0;\n   * directoryFileCounts.forEach(['src'], (value, prefix) => {\n   *   totalSourceFiles += value;\n   * });\n   * // totalSourceFiles (2 + 6) is now = 8\n   * ```\n   */\n  public forEach(\n    prefix: string[],\n    f: (value: T, prefix: string[]) => void,\n  ): TrieMap<T> {\n    prefix = prefix.slice();\n    (function recurse(node: obj) {\n      for (const key in node) {\n        prefix.push(key);\n        const value = node[key][SENTINEL];\n        if (value !== undefined) {\n          f(value, prefix.slice());\n        }\n        // TODO why is key !== '0' necessary?\n        if (key !== '0') recurse(node[key]);\n        prefix.pop();\n      }\n    })(this.getNode(prefix) || {});\n    return this;\n  }\n\n  /**\n   * Iterates all (value, prefix) where value === ´valueToFind´.\n   *\n   * @param prefix - A string array.\n   * @param valueToFind - The value to look for.\n   * @param f - A callback function.\n   *\n   * @example\n   * ```js\n   * const directoryFileCounts = new TrieMap()\n   *   .set(['src', 'classes'], 2)\n   *   .set(['src', 'modules'], 2)\n   *   .set(['docs'], 8);\n   *\n   * const directoryPathsWithTwoFiles = [];\n   * directoryFileCounts.find([], (value, prefix) => {\n   *   if(value === 2) {\n   *     directoryPathsWithTwoFiles.push(prefix);\n   *   }\n   * });\n   * // directoryPathsWithTwoFiles will now contain: [\n   * //   ['src', 'classes'],\n   * //   ['src', 'modules']\n   * // ]\n   * ```\n   */\n  public find(\n    prefix: string[],\n    valueToFind: T,\n    f: (value: T, prefix: string[]) => void,\n  ): TrieMap<T> {\n    this.forEach(prefix, (value, prefix) => {\n      if (value === valueToFind) {\n        f(valueToFind, prefix);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Returns an Iterable that yields each prefix in the TrieMap with the given prefix.\n   *\n   * @param prefix - A string array.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap()\n   *   .set(['src', 'classes'], 2)\n   *   .set(['src', 'modules'], 2)\n   *   .set(['docs'], 8);\n   *\n   * [...trie.keys()];\n   * //=> [\n   * //   ['src', 'classes'],\n   * //   ['src', 'modules'],\n   * //   ['docs']\n   * // ]\n   * ```\n   */\n  public *keys(prefix: string[] = []): Iterable<string[]> {\n    const res: string[][] = [];\n    this.forEach(prefix, (_, prefix) => {\n      return res.push(prefix);\n    });\n    yield* res;\n  }\n\n  /**\n   * Returns an Iterable that yields each value in the TrieMap with the given prefix.\n   *\n   * @param prefix - A string array.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap()\n   *   .set(['src', 'classes'], 2)\n   *   .set(['src', 'modules'], 2)\n   *   .set(['docs'], 8);\n   *\n   * [...trie.values()];\n   * //=> [2, 2, 8]\n   * ```\n   */\n  public *values(prefix: string[] = []): Iterable<T> {\n    const res: T[] = [];\n    this.forEach(prefix, (value: T) => {\n      return res.push(value);\n    });\n    yield* res;\n  }\n\n  /**\n   * Returns an Iterable that yields each entry ([prefix, value]) in the TrieMap with the given prefix.\n   *\n   * @param prefix - A string array.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap()\n   *   .set(['src', 'classes'], 2)\n   *   .set(['src', 'modules'], 2)\n   *   .set(['docs'], 8);\n   *\n   * [...trie.entries()];\n   * //=> [\n   * //   [['src', 'classes'], 2],\n   * //   [['src', 'modules'], 2],\n   * //   [['docs', 8]]\n   * // ]\n   * ```\n   */\n  public *entries(prefix: string[] = []): Iterable<[string[], T]> {\n    const res: Array<[string[], T]> = [];\n    this.forEach(prefix, (value, prefix) => {\n      res.push([prefix, value]);\n    });\n    yield* res;\n  }\n\n  /**\n   * Returns an Iterable that yields each entry ([prefix, value]) in the TrieMap with the given prefix.\n   *\n   * @param prefix - A string array.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap()\n   *   .set(['src', 'classes'], 2)\n   *   .set(['src', 'modules'], 2)\n   *   .set(['docs'], 8);\n   *\n   * [...trie];\n   * //=> [\n   * //   [['src', 'classes'], 2],\n   * //   [['src', 'modules'], 2],\n   * //   [['docs', 8]]\n   * // ]\n   * ```\n   */\n  public *[Symbol.iterator](prefix?: string[]): Iterable<[string[], T]> {\n    yield* this.entries(prefix);\n  }\n\n  /**\n   * Returns an Iterable that yields each entry ([prefix, value]) in the TrieMap with the given prefix.\n   *\n   * @param prefix - A string array.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap()\n   *   .set(['src', 'classes'], 2)\n   *   .set(['src', 'modules'], 2)\n   *   .set(['docs'], 8);\n   *\n   * trie.toArray();\n   * //=> [\n   * //   [['src', 'classes'], 2],\n   * //   [['src', 'modules'], 2],\n   * //   [['docs', 8]]\n   * // ]\n   * ```\n   */\n  public toArray(prefix: string[] = []): Array<[string[], T]> {\n    return [...this.entries(prefix)];\n  }\n\n  /**\n   * Returns the trie map data structure as pretty printed JSON.\n   *\n   * @param pretty - Whether to return a pretty formatted JSON string rather than a condensed machine readble string.\n   *\n   * @example\n   * ```js\n   * const trie = new TrieMap()\n   *   .set(['src', 'classes'], 2)\n   *   .set(['src', 'modules'], 2)\n   *   .set(['docs'], 8);\n   *\n   * trie.toJson();\n   * //=> \"{root:{src:{classes:2,modules:2,},docs:8,}}\"\n   *\n   * trie.toJson(true);\n   * //=> {\n   * //   root: {\n   * //     src: {\n   * //       classes: 2,\n   * //       modules: 2,\n   * //     },\n   * //     docs: 8,\n   * //   },\n   * // }\n   * ```\n   */\n  public toJson(pretty = false): string {\n    return JSON.stringify(this, null, pretty ? 2 : void 0);\n  }\n}\n\nexport default TrieMap;\n"],"names":["SENTINEL","String","fromCharCode","TrieMap","[object Object]","this","root","json","Object","setPrototypeOf","JSON","parse","prototype","iterable","instance","load","count","c","forEach","key","Error","create","prefix","value","set","node","i","length","ensureValidKey","undefined","f","Reflect","deleteProperty","nodeSetValue","setNode","getNode","nodeUpdateValue","nodeGetValue","get","nodeHasValue","parent","toPrune","pruneKey","numKeys","keys","delete","join","slice","recurse","push","pop","valueToFind","res","_","Symbol","iterator","entries","pretty","stringify"],"mappings":"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"}