/*!
 * @bemoje/trie-map v1.0.0
 * (c) Benjamin MÃ¸ller Jensen
 * Homepage: https://github.com/bemoje/trie-map
 * Released under the MIT License.
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TrieMap={})}(this,(function(e){"use strict";const t=String.fromCharCode(0);class TrieMap{constructor(){this.root={}}static fromJSON(e){return Object.setPrototypeOf(JSON.parse(e),this.prototype)}static fromIterable(e){const t=new this;return t.load(e),t}get count(){let e=0;return this.forEach([],(()=>{e++})),e}ensureValidKey(e){if(e===t||"0"===e)throw new Error("Prefix elements cannot be === to neither "+t+' || "0".')}clear(){return this.root=Object.create(null),this}load(e){for(const[t,r]of e)this.set(t,r);return this}setNode(e){let t=this.root;for(let r=0;r<e.length;r++)this.ensureValidKey(e[r]),t=t[e[r]]||(t[e[r]]=Object.create(null));return t}getNode(e){let t=this.root;for(let r=0;r<e.length;r++)if(this.ensureValidKey(e[r]),t=t[e[r]],void 0===t)return;return t}nodeSetValue(e,r){e[t]=r}nodeUpdateValue(e,r){e[t]=r(e[t])}nodeGetValue(e){return e[t]}nodeDeleteValue(e){return Reflect.deleteProperty(e,t)}nodeHasValue(e){return t in e}set(e,t){return this.nodeSetValue(this.setNode(e),t),this}update(e,t){const r=this.getNode(e);return r&&this.nodeUpdateValue(r,t),this}get(e){const t=this.getNode(e);if(t)return this.nodeGetValue(t)}getStrict(e){const t=this.get(e);if(!t)throw new Error("Value not found.");return t}has(e){const t=this.getNode(e);return!!t&&this.nodeHasValue(t)}delete(e){let r,o=this.root,n=null,s=null;for(let t=0;t<e.length;t++){if(r=o,o=o[e[t]],void 0===o)return!1;const i=Object.keys(o).length;null!==n?i>1&&(n=null,s=null):i<2&&(n=r,s=e[t])}return!!this.nodeHasValue(o)&&(n&&s?Reflect.deleteProperty(n,s):Reflect.deleteProperty(o,t),!0)}deleteStrict(e){if(!this.delete(e))throw new Error("The node at the prefix not found: "+e.join("/"))}forEach(e,r){return e=e.slice(),function recurse(o){for(const n in o){e.push(n);const s=o[n][t];void 0!==s&&r(s,e.slice()),"0"!==n&&recurse(o[n]),e.pop()}}(this.getNode(e)||{}),this}find(e,t,r){return this.forEach(e,((e,o)=>{e===t&&r(t,o)})),this}*keys(e=[]){const t=[];this.forEach(e,((e,r)=>t.push(r))),yield*t}*values(e=[]){const t=[];this.forEach(e,(e=>t.push(e))),yield*t}*entries(e=[]){const t=[];this.forEach(e,((e,r)=>{t.push([r,e])})),yield*t}*[Symbol.iterator](e){yield*this.entries(e)}toArray(e=[]){return[...this.entries(e)]}toJson(e=!1){return JSON.stringify(this,null,e?2:void 0)}}e.TrieMap=TrieMap,e.default=TrieMap,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.min.js.map
